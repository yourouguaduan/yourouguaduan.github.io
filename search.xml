<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[toppra]]></title>
    <url>%2F2019%2F10%2F22%2Ftoppra%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[hexo相关]]></title>
    <url>%2F2019%2F10%2F15%2F%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%8A%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[一、插入图片适用于我自己的特殊情况，在杨爱萍的方法无效后可以尝试。 1.调整程序配置文件_config.yml 里的post_asset_folder:这个选项设置为True； 2.在source下创建/images文件夹，先把图片xx.jpg/png复制到这个文件夹； 3.最后在xxxx.md中想引入图片时，只需要在xxxx.md中按照markdown的格式引入图片： 二、博客上公式换行用\\\\代替\\]]></content>
      <tags>
        <tag>插入图片 公式换行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows如何添加扫描仪]]></title>
    <url>%2F2019%2F10%2F14%2Fwindows%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E6%89%AB%E6%8F%8F%E4%BB%AA%2F</url>
    <content type="text"><![CDATA[1.首先安装驱动； 2.安装完成后，点击开始菜单，如下图所示； 3、点击EPSON Scan设置，链接选择网络，如下图所示; 4、点击添加，便会自动搜索，待搜索完成后，点击确定即可完成扫描仪的安装； 5、安装完成，可点击EPSON Scan扫描文件，如下图所示；]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ipdb包丢失后重新安装]]></title>
    <url>%2F2019%2F10%2F13%2Fipdb%E5%8C%85%E4%B8%A2%E5%A4%B1%E5%90%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[在运行Python代码的时候有时会因为环境产生ipdb包莫名奇妙丢失的状况，此时就需要对ipdb包就行重新安装。 首先检查通过正常方式是否可以成功安装ipdb 1234#打开新终端pip install ipdb#但该命令会安装失败，更改命令pip install ipdb -- user 若通过该方式无法正常安装，并且报如下错误 则需要按如下步骤执行 1234#打开新终端sudo apt remove python-pip#运行完之后pip install ipdb==0.10.2 一般情况下即可完成安装，若此步骤还无法进行安装，则首先查看Python已经安装的包 12#打开新终端pip list 输出列表中存在ipdb包，需要卸载ipdb之后重新进行安装，按以下步骤进行操作即可 123#打开新终端pip uninsthall ipdbpip install ipdb==0.10.2 --user]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[latex模板]]></title>
    <url>%2F2019%2F10%2F12%2Flatex%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[一、导言区12345678910111213\documentclass&#123;IEEEtran&#125;\title&#123;&#125;\author&#123;&#125;\date&#123;&#125;%根据需求添加，如果不需要时间空白即可\usepackage&#123;amsmath,amssymb,amsfonts&#125;\usepackage&#123;bm&#125;\usepackage[ruled,linesnumbered,lined]&#123;algorithm2e&#125;\usepackage&#123;algpseudocode&#125;\usepackage&#123;mathrsfs&#125;\usepackage&#123;url&#125;\usepackage&#123;caption&#125;\usepackage&#123;graphicx,subfig&#125;\usepackage&#123;balance&#125;%用于控制参考文献在两侧均匀分布 二、文本区12\begin&#123;document&#125;\maketitle 1.论文不需要添加页码时输入的指令如下：12\pagestyle&#123;empty&#125;\thispagestyle&#123;empty&#125; 2.标题：123\section%输入一级标题\subsection%输入二级标题\subsubsection%输入三级标题 以此类推 3.字体相关输入3.1字体加粗1\textbf&#123;&#125; 3.2输入斜体1\emph&#123;&#125; 3.3添加上划线下划线12\overline&#123;&#125;%上划线\underline&#123;&#125;%下划线 3.4输入花体字母（仅限于大写字母）1\mathcal&#123;&#125; 4.数学公式相关输入4.1添加下标和指数12&#123;&#125;_&#123;&#125;%下标&#123;&#125;^&#123;&#125;%指数 4.2常见数学符号的输入方法https://blog.csdn.net/dingchenxixi/article/details/50752292 4.3积分符号的输入方法1\int_&#123;&#125;^&#123;&#125;&#123;&#125;d&#123;&#125;%第一个中括号的内容为积分下限，第二个中括号内容为积分上限，第三个中括号内容为被积函数，第四个中括号内容为自变量 4.4数学公式的输入方式1 1.$&#123;&#125;$%直接输入公式，公式不带有序号 2. 123\begin&#123;equation&#125; \end&#123;equation&#125;%单行公式带序号的输入方法 3. 123\begin&#123;equation*&#125;\end&#123;equation*&#125;%单行公式不带序号的输入方法 4. 12\begin&#123;align&#125;\end&#123;align&#125;%多行公式带序号的输入方法（每行公式都带有序号），通过&quot;\\&quot;换行如果有几行公式不需要序号可在该行公式后面输入&quot;\notag&quot; 如下图所示 5. 12345#写多行式子且编号放在整个式子中间，每一行通过&quot;\\&quot;分割\begin&#123;equation&#125;\begin&#123;split&#125;\begin&#123;split&#125;\end&#123;equation&#125; 6.多行式子需要在指定位置对齐时，需要在对齐位置前添加“$”,如下图所示。 7.矩阵的输入方法 12345\[&#123;矩阵的名字&#125;=\begin&#123;&#125;%根据矩阵的类型选择输入内容，输入matrix矩阵无括号，输入pmatrix矩阵有小括号，输入bmatrix矩阵有中括号，Bmatrix矩阵有大括号，vmatrix矩阵有单竖线，Vmatrix矩阵有双竖线 &amp; \\%矩阵中用“&amp;”分割列，用“\\”分隔行，使用指令&quot;\dots&quot;添加横向省略号，使用指令“\vdots”添加竖向省略号，使用指令“\ddots”添加斜向右省略号 \end&#123;&#125;_&#123;n \times n&#125;%与begin中的内容相一致,需要添加角标时可以添加后方指令] 8.公式内矩阵的输入方法 1234567\begin&#123;equation&#125;\left[\begin&#123;smallmatrix&#125;&#123;&#125;%公式内的矩阵内容\end&#123;smallmatrix&#125;\right]\tag&#123;&#125; %添加公式编号\end&#123;equation&#125; mathpix软件可以直接把公式生成LaTeX代码，推荐使用，提高效率。可以在官网上下载 mathpix使用简单教程：https://danielzph.github.io/2019/10/tool_mathpix/ 5.插图及相关内容的输入12345\begin&#123;figure*&#125;[htp]\centering\includegraphics[&lt;选项&gt;]&#123;&lt;文件名&gt;&#125;%[]中可添加缩放比例（scale=）以及旋转等，注意文件必须放置和tex文件放置在同一个文件夹中\caption&#123;&#125;%在图片下方添加备注\end&#123;figure*&#125; 6.表格及相关内容的输入6.1 一般表格画法例子解析 123456789101112\begin&#123;table&#125;\centering %表格居中\caption&#123;Results for 32 replanning problems on WAM&#125; %输入标题 \begin&#123;tabular&#125;&#123;|c|c c|&#125; %‘|’代表竖线，c代表一列 \hline % 行线 &amp; iGMP2 &amp; GPMP2\\ \hline %每行中的数据或文字内容用‘&amp;’隔开Success Rate(\%) &amp; 90.6 &amp; \textbf&#123;100.0&#125; \\ %\textbf&#123;&#125;表示字符加粗。Average Time to Sucess(ms) &amp; \textbf&#123;2.38&#125; &amp; 30.21 \\ Maximum Time to Success(ms) &amp; \textbf&#123;3.92&#125; &amp; 46.60 \\ \hline\end&#123;tabular&#125;\end&#123;table&#125; 如图3所示。 6.2 伪代码例子 12345678910111213141516\begin&#123;algorithm&#125; \caption&#123;Replanning using iSAM2&#125; %输入标题\label&#123;&#125;\KwIn&#123;new factors $f_&#123;start&#125;$,replaced factors $f_&#123;replace&#125;$&#125; % 输入Input内容\KwOut&#123;updated optimal trajectory $\theta^*$ \\Initialization :&#125; %输入output内容add factors$f_&#123;odd&#125;=\emptyset$, remove factors $f_&#123;remove&#125;=\emptyset$ \quad iSAM2 update :) \\$f_&#123;odd&#125;=f_&#123;new&#125;$\\\If &#123;($f_&#123;replace&#125;\neq \emptyset$)&#125; &#123; $f_&#123;odd&#125;=f_&#123;odd&#125;+f&#123;replace&#125;$\\ $f_&#123;remove&#125;=findOldFactors(f_&#123;replace&#125;)$&#125;&#123;iSAM2.updateBayesTree(f add , f remove )&#125;\\\Return iSAM2.getCurrentEstimation()\end&#123;algorithm&#125; 格式如图4所示： 7.因子图画法12345678910111213141516171819202122232425262728293031323334353637383940\begin&#123;figure&#125;\begin&#123;tikzpicture&#125; \filldraw[black] (0,0) circle [radius=2pt] %画黑色实心圆 (1,0) circle [radius=2pt] (2,0) circle [radius=2pt] (3,0) circle [radius=2pt] (4,0) circle [radius=2pt] (5,0) circle [radius=2pt]; \draw (0.5,0) circle [radius=4pt] %画空心圆 (1.5,0) circle [radius=4pt] (2.5,0) circle [radius=4pt] (3.5,0) circle [radius=4pt] (4.5,0) circle [radius=4pt]; \filldraw[black] (0.5,0.5) circle [radius=2pt] (1.5,0.5) circle [radius=2pt] (2.5,0.5) circle [radius=2pt] (3.5,0.5) circle [radius=2pt] (4.5,0.5) circle [radius=2pt]; \draw (0,0) -- (5,0) (0.5,0) -- (0.5,0.5) (1.5,0) -- (1.5,0.5) (2.5,0) -- (2.5,0.5) (3.5,0)--(3.5,0.5) (4.5,0) -- (4.5,0.5); %画直线 \draw (7,0.5) ellipse [x radius=0.6cm, y radius=0.2cm] %画椭圆 (7,-0.1) ellipse [x radius=0.6cm, y radius=0.2cm] (7,-0.7) ellipse [x radius=0.6cm, y radius=0.2cm] (7,-1.3) ellipse [x radius=0.6cm, y radius=0.2cm]; \node at (7,0.5) &#123;$\theta_4,\theta_3$&#125;; %标记某个点的名称 \node at (7,-0.1) &#123;$\theta_2:\theta_3$&#125;; \node at (7,-0.7) &#123;$\theta_1:\theta_2$&#125;; \node at (7,-1.3) &#123;$\theta_0:\theta_1$&#125;; \draw [-&gt;] (7,0.3) -- (7,0.1) (7,-0.3) -- (7,-0.5) (7,-0.9) -- (7,-1.1); %用带箭头的线连线 \node [below] at (0.5,-0.1) &#123;$\theta_0$&#125;; \node [below] at (1.5,-0.1) &#123;$\theta_1$&#125;; \node [below] at (2.5,-0.1) &#123;$\theta_2$&#125;; \node [below] at (3.5,-0.1) &#123;$\theta_3$&#125;; \node [below] at (4.5,-0.1) &#123;$\theta_4$&#125;;\end&#123;tikzpicture&#125;\caption&#123; &#125; %加入因子图下加入标题。 \end&#123;figure&#125; 如图5所示 8.参考文献的插入12345678\begin&#123;thebibliography&#125;&#123;99&#125; % 99为参考文献最大数目，可自行修改不重要。\bibitem&#123;c1&#125; + ... + \emph&#123;...&#125; + ... % \emph&#123;&#125;内容变成斜体。\bibitem&#123;c2&#125; + ... + \emph&#123;...&#125; + ...\bibitem&#123;c3&#125; + ... + \emph&#123;...&#125; + ...\...\end&#123;thebibliography&#125; 三、结尾1\end&#123;document&#125;]]></content>
      <tags>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[robotsp笔记]]></title>
    <url>%2F2019%2F10%2F08%2Frobotsp%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、Python基本语法line 57:设置六个关节初始角度 def repr 帮助显示函数属性 def str 帮忙打印函数属性 xrange生成若干个数 dir() # 获得当前模块的属性列表 enumerate() 函数用于将一个可遍历的数据对象 os.path.isdir(path)判断路径是否为目录 os.path.join(path1[, path2[, …]])将目录和文件名合成为一个路径 os.path.expanduser(path)把path中包含的”“和”user”转换成用户目录 二、程序与论文对应内容1.iksolutions求解并计算求解时间solver.py line 103 1234567891011121314starttime = time.time() configurations = [] if qstart is not None: configurations.append([qstart]) for i,ray in enumerate(targets): newpos = ray.pos() - params.standoff*ray.dir() newray = orpy.Ray(newpos, ray.dir()) solutions = ru.kinematics.find_ik_solutions(robot, newray, params.iktype, collision_free=True, freeinc=params.step_size) if len(solutions) == 0: raise Exception(&apos;Failed to find IK solution for target %d&apos; % i) configurations.append(solutions) cpu_time = time.time() - starttime return configurations, cpu_time 2.解决RTSP的三步算法step 1 :在任务空间矩阵中找到最佳的访问目标顺序solver.py line 246 123456tgraph = rtsp.construct.from_coordinate_list(coordinates, distfn=params.tspace_metric, args=params.tspace_metric_args) starttime = time.time() ttour = params.tsp_solver(tgraph) ttour = rtsp.tsp.rotate_tour(ttour, start=0) # Start from robot home tsp_cpu_time = time.time() - starttime step 2 :基于步骤1，为每个目标点找到最佳的位姿solver.py line 253 123456789setslist = [configurations[n] for n in ttour] setslist += [[qhome]] starttime = time.time() cgraph, bins = rtsp.construct.from_sorted_setslist(setslist, distfn=params.cspace_metric, args=params.cspace_metric_args) metric_cpu_time = time.time() - starttime starttime = time.time() ctour = nx.dijkstra_path(cgraph, source=0, target=cgraph.number_of_nodes()-1) dijkstra_cpu_time = time.time() - starttime setp 3 :确定计算最终的无碰撞轨迹solver.py line 263 1234trajectories, traj_cpu_times = compute_cspace_trajectories(robot, cgraph, ctour, params) solver_cpu_time = time.time() - solver_starttime info = dict() 3.添加连接（edge）parser.py line 82 12345678910111213141516171819202122232425 x = graph.node[i][&apos;coordinate&apos;] y = graph.node[j][&apos;coordinate&apos;] graph.add_edge(i, j, weight=distfn(x, y))else: weight_format = SUPPORTED_WEIGHT_FORMATS[tsp_dict[&apos;EDGE_WEIGHT_FORMAT&apos;]] if weight_format == SUPPORTED_WEIGHT_FORMATS.LOWER_DIAG_ROW: i,j = (0,0) for row in tsp_dict[&apos;EDGE_WEIGHT_SECTION&apos;]: for w in row: if i != j: graph.add_edge(i, j, weight=w) j += 1 if j &gt; i: i += 1 j = 0 elif weight_format == SUPPORTED_WEIGHT_FORMATS.FULL_MATRIX: i,j = (0,0) for row in tsp_dict[&apos;EDGE_WEIGHT_SECTION&apos;]: for w in row: if i != j: graph.add_edge(i, j, weight=w) j += 1 if j == dimension: i += 1 j = 0 4. 2-opt123456789101112131415161718192021222324def two_opt(graph, weight=&apos;weight&apos;): num_nodes = graph.number_of_nodes() tour = graph.nodes() # min_cost = compute_tour_cost(graph, tour) start_again = True while start_again: start_again = False for i in xrange(0, num_nodes-1): for k in xrange(i+1, num_nodes): # 2-opt swap a, b = tour[i-1], tour[i] c, d = tour[k], tour[(k+1)%num_nodes] if (a == c) or (b == d): continue ab_cd_dist = graph.edge[a][b][weight] + graph.edge[c][d][weight] ac_bd_dist = graph.edge[a][c][weight] + graph.edge[b][d][weight] if ab_cd_dist &gt; ac_bd_dist: tour[i:k+1] = reversed(tour[i:k+1]) start_again = True if start_again: break if start_again: break return tour 5.解决tsp的最短路径算法12345678910111213141516171819202122232425262728def nearest_neighbor(graph, restarts=10, weight=&apos;weight&apos;): restarts = min(restarts, graph.number_of_nodes()) nodelist = graph.nodes() tried_nodes = [] min_cost = float(&apos;inf&apos;) for _ in xrange(restarts): while True: current_node = np.random.choice(nodelist) if current_node not in tried_nodes: tried_nodes.append(current_node) break g = graph.copy() tour = [current_node] while g.number_of_nodes() &gt; 1: min_weight = float(&apos;inf&apos;) for neighbor in g.neighbors_iter(current_node): w = g.edge[current_node][neighbor][weight] if w &lt; min_weight: nn = neighbor min_weight = w g.remove_node(current_node) tour.append(nn) current_node = nn cost = compute_tour_cost(graph, tour) if cost &lt; min_cost: min_cost = cost best_tour = list(tour) return best_tour 6.欧式距离的计算123456def euclidean_fn(x, y, weights=None): if weights is None: distance = math.sqrt(np.sum((x-y)**2)) else: distance = math.sqrt(np.sum(weights*(x-y)**2)) return distance 三、robotsp算法step1:确定任务点的访问顺序，输出为ttour，就是经典的旅行商问题from_coordinate_list 1：采用欧式距离计算公式，算出最短的任务点访问顺序 rotate_tour：新的任务点访问顺序的起点 这一过程的伪代码如下方所示 123456789101112131415\documentclass&#123;article&#125;\usepackage[ruled,linesnumbered,lined]&#123;algorithm2e&#125;\usepackage[backend=bibtex,style=verbose-trad2,natbib=true]&#123;biblatex&#125;\begin&#123;document&#125;\begin&#123;algorithm&#125;\caption&#123;Find the ttour&#125;\label&#123;&#125;\KwIn&#123;coordinates&#125;\KwOut&#123;ttour \\Initialization:&#125; tgraph $\gets$ FROM\_COORDINATE\_LIST(coordinates)\\ ttour $\gets$ tsp\_solver(tgraph)\\ ttour $\gets$ rotate\_tour(ttour)\\ return ttour\end&#123;algorithm&#125;\end&#123;document&#125; step 2:确定访问任务点的位姿，输出为ctourfrom_sorted_setslist函数中set_sizes表示层数，产生的图为论文中的fig.3，start即为fig.3中的qstart，stop即为fig.3中的qgoal 这一过程的伪代码如下方所示 123456789101112131415161718\documentclass&#123;article&#125;\usepackage[ruled,linesnumbered,lined]&#123;algorithm2e&#125;\usepackage[backend=bibtex,style=verbose-trad2,natbib=true]&#123;biblatex&#125;\begin&#123;document&#125;\setcounter&#123;algocf&#125;&#123;1&#125;\begin&#123;algorithm&#125;\caption&#123;Find the ctour&#125;\label&#123;&#125;\KwIn&#123;ttour qhome&#125;\KwOut&#123;ctour \\Initialization:&#125;\For &#123;n in ttour&#125; &#123;$setslist \gets [configurations[n]]$&#125; setslist$\gets$ setslist+ [qhome]\\ cgraph $\gets$ from\_sorted\_setslist(setslist)\\ ctour $\gets$ dijkstra\_path(cgraph)\\ return ctour\end&#123;algorithm&#125;\end&#123;document&#125; step 3：将ttour和ctour结合，输出配置空间中的轨迹这一过程的伪代码如下方所示 1234567891011121314\documentclass&#123;article&#125;\usepackage[ruled,linesnumbered,lined]&#123;algorithm2e&#125;\usepackage[backend=bibtex,style=verbose-trad2,natbib=true]&#123;biblatex&#125;\begin&#123;document&#125;\setcounter&#123;algocf&#125;&#123;2&#125;\begin&#123;algorithm&#125;\caption&#123;Find the ctour&#125;\label&#123;&#125;\KwIn&#123;cgraph ctour&#125;\KwOut&#123;trajectories \\Initialization:&#125;trajectories $\gets$ compute\_cspace\_trajectories(cgraph ctour)\\return trajectories\\\end&#123;algorithm&#125;\end&#123;document&#125;]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人学公式推导]]></title>
    <url>%2F2019%2F10%2F08%2F%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[一、线性微分方程理论的基本结果由一阶线性微分方程$\dot{x}(t)=ax(t)$可得$x(t)=e^{at}x_0$,对$e^{at}$利用泰勒公式展开可得$e^{at}=1+at+{(at)^2}/2!+{(at)^3}/3!+\cdots$，代入线性微分方程的解中可以得到$x(t)=(1+at+{(at)^2}/2!+{(at)^3}/3!+\cdots)x_0$。 由此实数a用矩阵A代替，得$x(t)=(I+At+{(At)^2}/2!+{(At)^3}/3!+\cdots)x_0$，公式两侧对t进行求导可得$$\begin{aligned} \dot{x}(t) &amp;=\left(\frac{d}{d t} e^{A t}\right) x_{0} \\ &amp;=\frac{d}{d t}\left(I+A t+\frac{A^{2} t^{2}}{2 !}+\frac{A^{3} t^{3}}{3 !}+\cdots\right) x_{0} \\ &amp;=\left(A+A^{2} t+\frac{A^{3} t^{2}}{2 !}+\cdots\right) x_{0} \\ &amp;=A e^{A t} x_{0} \\ &amp;=A x(t) \end{aligned}$$由此可以证明$x(t)=e^{At}x_0$。 对于任意的矩阵A和标量t，都存在$Ae^{At}=e^{At}A$,由此可以推导出$\dot{x}(t)=e^{A t} A x_{0}$。因为$e^{At}$是无穷级数，因此通常在使用时将其转化为近似形式的表达式子更为可行。例如，将A用$A=P D P^{-1}$表示并带入$e^{At}$的泰勒展开式中可以得到如下等式。$$\begin{aligned} e^{A t} &amp;=I+A t+\frac{(A t)^{2}}{2 !}+\cdots \\ &amp;=I+\left(P D P^{-1}\right) t+\left(P D P^{-1}\right)\left(P D P^{-1}\right) \frac{t^{2}}{2 !}+\cdots \\ &amp;=P\left(I+D t+\frac{(D t)^{2}}{2 !}+\cdots\right) P^{-1} \\ &amp;=P e^{D t} P^{-1} \end{aligned}$$ 二、旋转指数坐标旋转的指数坐标可以等效地视为一个单位旋转轴$\hat{\omega}\left(\hat{\omega} \in \mathbb{R}^{3},|\hat{\omega}|=1\right)$和绕该轴旋转角度$\theta \in \mathbb{R}$或者也可以等效的视为将两者相乘得到的三维向量$\hat{\omega} \theta \in \mathbb{R}^{3}$]]></content>
      <tags>
        <tag>MR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[工作记录]]></title>
    <url>%2F2019%2F09%2F25%2F%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[一、《ROS机器人开发实践》学习至7.1节，完成在Gazebo环境中对于机器人的模拟仿真。 二、论文翻译与复现1.论文翻译《GPMP》论文阅读至第二部分，第二部分公式较多需要较长时间的阅读理解。 2.论文复现使用texmaker对《GPMP》的复现工作的整体框架已经完成，待完成图片插入，文献引用的工作。 三、github博客完成hexo+github博客的创建工作。 四、slam小车相关任务实现电机的转动功能，搜集关于如何实现小车走s线的相关资料。]]></content>
      <tags>
        <tag>工作记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作记录（2）]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、《ROS机器人开发实践》学习至8.2节。 二、论文翻译与复现1、论文翻译阅读《GPMP》论文中，公式推导进程较慢。 2、论文复现已完成论文的复现工作，同时整理latex模板中。 三、github博客添加评论和搜索功能 四、slam小车相关工作编写走s形道路的程序中。]]></content>
      <tags>
        <tag>工作记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电机转动步骤及相关注意事项]]></title>
    <url>%2F2019%2F08%2F25%2F%E7%94%B5%E6%9C%BA%E8%BD%AC%E5%8A%A8%E6%AD%A5%E9%AA%A4%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[一、接线将电源与主板相连接（此次对主板采用12v供电方案）按下开关键，利用micro usb将主板与上位机（即Ubuntu系统的电脑）相连接，将主板与电机相连，完成接线步骤。 二、环境配置1.小车端环境的配置1234567891011cd ~/pibot_ros# 更新代码git pull # 按实际情况选择相应的小车类型，控制板类型，雷达类型，Machine（这里选0）./pibot_init_env.sh source ~/.bashrccd ~/pibot_ros/ros_ws/# 对PIBOT文件进行编译catkin_makesource ~/.bashrc 2.Ubuntu主机环境的配置首先将pibot_ros.tar.bz2复制至主目录，然后打开新终端，输入如下代码 12345678910111213141516# 打开新终端cd ~# 解压tar jxvf pibot_ros.tar.bz2cd ~/pibot_ros#这里根据提示输入小车类型，控制板类型，雷达类型，Machine类型(这里选1)./pibot_init_env.sh source ~/.bashrccd ~/pibot_ros/ros_ws/# 对PIBOT文件进行编译catkin_makesource ~/.bashrc 三、驱动电机1、安装脚本打开pibot_ros文件夹，打开新终端，对pibot_install_ros.sh和pibot_add_upstart.sh两个脚本进行安装。 2、测试硬件连接状态输入以下内容查看硬件链接是否正常。 12# 打开新终端ls /dev/pibot -l 3、实现电机转动12#打开新终端pibot_bringup 12#打开新终端pibot_control 键盘上按下i键，电机转动。 四、可能遇到的问题1、出现resourcenotfound在打开的新终端中输入pibot_control之后，出现resourcenotfound的情况，可能是未对脚本进行正确的安装，在终端中将pibot_install_ros.sh和pibot_add_upstart.sh两个脚本进行安装即可解决。 2、输出的信息正确但电机不转动①主板底层未收到信息安装串口调试工具（以下以cutecom为例），查看输出栏是否有信息正常输出。 123456789101112#下载安装命令sudo apt-get install cutecom#运行cutecom软件sudo cutecom#查看主板连接端口ls /dev/pibot -l#对cutecom面板里的device进行对应选择或修改#打开新终端pibot_bringup#打开新终端pibot_control#按下i，并点击cutecom面板的open 如果输出板有输出（如下图）则证明底层接受信息正常，反之则证明底层接受出现问题。 ②电源接线问题如果串口调试正常，有可能是电源问题或者接线问题。查看单元接口处开关是否正常，查看主板与电机的接线是否正常连接。]]></content>
      <tags>
        <tag>电机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo+github搭建免费个人博客]]></title>
    <url>%2F2019%2F08%2F18%2F%E4%BD%BF%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[[https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html]:]]></content>
  </entry>
  <entry>
    <title><![CDATA[my-first-blog]]></title>
    <url>%2F2019%2F08%2F18%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[第一次使用，请多指教]]></content>
  </entry>
</search>
